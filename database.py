import sqlalchemy as sa
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.dialects.postgresql import UUID
import uuid

# Database setup
DATABASE_URL = "sqlite:///./jobs.db"
engine = sa.create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Define the Jobs model
class Job(Base):
    __tablename__ = "jobs"
    
    id = sa.Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    payment_id = sa.Column(sa.String)
    status = sa.Column(sa.String)
    payment_status = sa.Column(sa.String)
    input_data = sa.Column(sa.String)
    input_hash = sa.Column(sa.String) # Generated and returned from Payment Service
    result = sa.Column(sa.String)
    result_hash = sa.Column(sa.String) # Generated by the Agent
    cost = sa.Column(sa.String) # This is the amount of lovelaces (as string) that job will cost
    identifier_from_purchaser = sa.Column(sa.String)

# This function returns a generator that yields a database session.
# It must be used with the `next()` function from within another function body
# Example usage:
#   db = next(get_db())
#   try:
#       # Use db session here
#   finally:
#       db.close()
#
# Or with FastAPI Depends:
#   @app.get("/items/")
#   def read_items(db: Session = Depends(get_db)):
#       # Use db session here directly
#       # FastAPI handles closing the session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Create tables
Base.metadata.create_all(bind=engine)
